// This file is auto-generated by @hey-api/openapi-ts

import { z } from 'zod';

/**
 * Lightweight model representation for listings
 */
export const zModelSummary = z
  .object({
    id: z.string().register(z.globalRegistry, {
      description: 'Fully qualified ID (database.table)',
    }),
    type: z.enum(['external', 'transformation']).register(z.globalRegistry, {
      description: 'Model type',
    }),
    database: z.string(),
    table: z.string(),
    description: z.optional(z.string()),
  })
  .register(z.globalRegistry, {
    description: 'Lightweight model representation for listings',
  });

export const zExternalModel = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Fully qualified ID (database.table)',
  }),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  interval: z.optional(
    z
      .object({
        type: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Type of interval (e.g., "second", "slot", "epoch", "block")',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'Interval configuration for external source',
      })
  ),
  cache: z.optional(
    z
      .object({
        incremental_scan_interval: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Interval for incremental cache updates',
          })
        ),
        full_scan_interval: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Interval for full cache refresh',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'Cache configuration for external source',
      })
  ),
  lag: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of blocks/slots to lag behind head',
    })
  ),
  metadata: z.optional(
    z
      .object({
        created_at: z.optional(z.iso.datetime()),
        updated_at: z.optional(z.iso.datetime()),
        last_synced_at: z.optional(z.iso.datetime()),
        row_count: z.optional(
          z.int().register(z.globalRegistry, {
            description: 'Approximate row count in destination table',
          })
        ),
        size_bytes: z.optional(
          z.int().register(z.globalRegistry, {
            description: 'Approximate table size in bytes',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'System-managed metadata',
      })
      .readonly()
  ),
});

export const zTransformationModelBase = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Fully qualified ID (database.table)',
  }),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  type: z.enum(['scheduled', 'incremental']).register(z.globalRegistry, {
    description: 'Transformation type (scheduled or incremental)',
  }),
  content_type: z.enum(['sql', 'exec']).register(z.globalRegistry, {
    description: 'Execution method (SQL query or shell command)',
  }),
  content: z.string().register(z.globalRegistry, {
    description: 'SQL query or exec command defining the transformation',
  }),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'Tags for categorization',
    })
  ),
  depends_on: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'Upstream model dependencies',
    })
  ),
  metadata: z.optional(
    z
      .object({
        created_at: z.optional(z.iso.datetime()),
        updated_at: z.optional(z.iso.datetime()),
        last_run_at: z.optional(z.iso.datetime()),
        last_run_status: z.optional(z.enum(['success', 'failed', 'running', 'pending'])),
        row_count: z.optional(z.int()),
        size_bytes: z.optional(z.int()),
      })
      .register(z.globalRegistry, {
        description: 'System-managed metadata',
      })
      .readonly()
  ),
});

export const zScheduledTransformation = zTransformationModelBase.and(
  z.object({
    type: z.optional(z.enum(['scheduled'])),
    schedule: z.string().register(z.globalRegistry, {
      description: 'Cron expression (REQUIRED for scheduled type)',
    }),
  })
);

export const zIncrementalTransformation = zTransformationModelBase.and(
  z.object({
    type: z.optional(z.enum(['incremental'])),
    interval: z
      .object({
        min: z.int().register(z.globalRegistry, {
          description: 'Minimum interval size (0 = allow any partial size)',
        }),
        max: z.int().register(z.globalRegistry, {
          description: 'Maximum interval size for processing',
        }),
        type: z.string().register(z.globalRegistry, {
          description: 'Type of interval (e.g., "second", "slot", "epoch", "block")',
        }),
      })
      .register(z.globalRegistry, {
        description: 'Interval configuration (REQUIRED for incremental type)',
      }),
    schedules: z.optional(
      z
        .object({
          forwardfill: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Forward fill schedule',
            })
          ),
          backfill: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Backfill schedule',
            })
          ),
        })
        .register(z.globalRegistry, {
          description: 'Forwardfill and backfill schedules (for incremental type)',
        })
    ),
    limits: z.optional(
      z
        .object({
          min: z.optional(
            z.int().register(z.globalRegistry, {
              description: 'Minimum position limit',
            })
          ),
          max: z.optional(
            z.int().register(z.globalRegistry, {
              description: 'Maximum position limit',
            })
          ),
        })
        .register(z.globalRegistry, {
          description: 'Position limits for incremental processing',
        })
    ),
  })
);

export const zTransformationModel = zTransformationModelBase.and(
  z.object({
    schedule: z.optional(
      z.string().register(z.globalRegistry, {
        description: 'Cron expression (present when type=scheduled)',
      })
    ),
    interval: z.optional(
      z
        .object({
          min: z.optional(
            z.int().register(z.globalRegistry, {
              description: 'Minimum interval size',
            })
          ),
          max: z.optional(
            z.int().register(z.globalRegistry, {
              description: 'Maximum interval size',
            })
          ),
          type: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Type of interval (e.g., "second", "slot", "epoch", "block")',
            })
          ),
        })
        .register(z.globalRegistry, {
          description: 'Interval configuration (present when type=incremental)',
        })
    ),
    schedules: z.optional(
      z
        .object({
          forwardfill: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Forward fill schedule',
            })
          ),
          backfill: z.optional(
            z.string().register(z.globalRegistry, {
              description: 'Backfill schedule',
            })
          ),
        })
        .register(z.globalRegistry, {
          description: 'Schedules (present when type=incremental)',
        })
    ),
    limits: z.optional(
      z
        .object({
          min: z.optional(
            z.int().register(z.globalRegistry, {
              description: 'Minimum position limit',
            })
          ),
          max: z.optional(
            z.int().register(z.globalRegistry, {
              description: 'Maximum position limit',
            })
          ),
        })
        .register(z.globalRegistry, {
          description: 'Limits (present when type=incremental)',
        })
    ),
  })
);

export const zExternalBounds = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Fully qualified model ID (database.table)',
  }),
  min: z.int().register(z.globalRegistry, {
    description: 'Minimum position in external source',
  }),
  max: z.int().register(z.globalRegistry, {
    description: 'Maximum position in external source',
  }),
  previous_min: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Previous minimum position (for tracking changes)',
    })
  ),
  previous_max: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Previous maximum position (for tracking changes)',
    })
  ),
  last_incremental_scan: z.optional(
    z.iso.datetime().register(z.globalRegistry, {
      description: 'Timestamp of last incremental scan',
    })
  ),
  last_full_scan: z.optional(
    z.iso.datetime().register(z.globalRegistry, {
      description: 'Timestamp of last full scan',
    })
  ),
  initial_scan_complete: z.optional(
    z.boolean().register(z.globalRegistry, {
      description: 'Whether initial scan is complete',
    })
  ),
  initial_scan_started: z.optional(
    z.iso.datetime().register(z.globalRegistry, {
      description: 'Timestamp when initial scan started',
    })
  ),
});

export const zRange = z.object({
  position: z.int().register(z.globalRegistry, {
    description: 'Starting position of processed range',
  }),
  interval: z.int().register(z.globalRegistry, {
    description: 'Size of processed range',
  }),
});

export const zCoverageSummary = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Fully qualified model ID (database.table)',
  }),
  ranges: z.array(zRange).register(z.globalRegistry, {
    description: 'Processed ranges from admin_incremental table',
  }),
});

export const zCoverageDetail = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Fully qualified model ID (database.table)',
  }),
  ranges: z.array(zRange).register(z.globalRegistry, {
    description: 'All processed ranges from admin_incremental table',
  }),
});

export const zScheduledRun = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Fully qualified model ID (database.table)',
  }),
  last_run: z.optional(
    z.iso.datetime().register(z.globalRegistry, {
      description: 'Timestamp of last execution',
    })
  ),
});

export const zError = z.object({
  error: z.string().register(z.globalRegistry, {
    description: 'Human-readable error message',
  }),
  code: z.int().register(z.globalRegistry, {
    description: 'HTTP status code',
  }),
});

export const zExternalModelWritable = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Fully qualified ID (database.table)',
  }),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  interval: z.optional(
    z
      .object({
        type: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Type of interval (e.g., "second", "slot", "epoch", "block")',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'Interval configuration for external source',
      })
  ),
  cache: z.optional(
    z
      .object({
        incremental_scan_interval: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Interval for incremental cache updates',
          })
        ),
        full_scan_interval: z.optional(
          z.string().register(z.globalRegistry, {
            description: 'Interval for full cache refresh',
          })
        ),
      })
      .register(z.globalRegistry, {
        description: 'Cache configuration for external source',
      })
  ),
  lag: z.optional(
    z.int().register(z.globalRegistry, {
      description: 'Number of blocks/slots to lag behind head',
    })
  ),
});

export const zTransformationModelBaseWritable = z.object({
  id: z.string().register(z.globalRegistry, {
    description: 'Fully qualified ID (database.table)',
  }),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  type: z.enum(['scheduled', 'incremental']).register(z.globalRegistry, {
    description: 'Transformation type (scheduled or incremental)',
  }),
  content_type: z.enum(['sql', 'exec']).register(z.globalRegistry, {
    description: 'Execution method (SQL query or shell command)',
  }),
  content: z.string().register(z.globalRegistry, {
    description: 'SQL query or exec command defining the transformation',
  }),
  tags: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'Tags for categorization',
    })
  ),
  depends_on: z.optional(
    z.array(z.string()).register(z.globalRegistry, {
      description: 'Upstream model dependencies',
    })
  ),
});

export const zListAllModelsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      type: z.optional(
        z.enum(['external', 'transformation']).register(z.globalRegistry, {
          description: 'Filter by model type',
        })
      ),
      database: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Filter by database name',
        })
      ),
      search: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Search by model ID or description (case-insensitive)',
        })
      ),
    })
  ),
});

/**
 * List of all models (summary view)
 */
export const zListAllModelsResponse = z
  .object({
    models: z.array(zModelSummary),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description: 'List of all models (summary view)',
  });

export const zListExternalModelsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Filter by database name',
        })
      ),
    })
  ),
});

/**
 * List of external models
 */
export const zListExternalModelsResponse = z
  .object({
    models: z.array(zExternalModel),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description: 'List of external models',
  });

export const zGetExternalModelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'Fully qualified model ID (database.table)',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * External model details
 */
export const zGetExternalModelResponse = zExternalModel;

export const zListTransformationsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Filter by database name',
        })
      ),
      type: z.optional(
        z.enum(['scheduled', 'incremental']).register(z.globalRegistry, {
          description: 'Filter by transformation type',
        })
      ),
      status: z.optional(
        z.enum(['success', 'failed', 'running', 'pending']).register(z.globalRegistry, {
          description: 'Filter by last run status',
        })
      ),
    })
  ),
});

/**
 * List of transformation models
 */
export const zListTransformationsResponse = z
  .object({
    models: z.array(zTransformationModel),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description: 'List of transformation models',
  });

export const zGetTransformationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'Fully qualified model ID (database.table)',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Transformation model details
 */
export const zGetTransformationResponse = zTransformationModel;

export const zListExternalBoundsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * List of external model bounds
 */
export const zListExternalBoundsResponse = z
  .object({
    bounds: z.array(zExternalBounds),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description: 'List of external model bounds',
  });

export const zGetExternalBoundsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'Fully qualified model ID (database.table)',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * External model bounds details
 */
export const zGetExternalBoundsResponse = zExternalBounds;

export const zListTransformationCoverageData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Filter by database name',
        })
      ),
    })
  ),
});

/**
 * List of transformation coverage
 */
export const zListTransformationCoverageResponse = z
  .object({
    coverage: z.array(zCoverageSummary),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description: 'List of transformation coverage',
  });

export const zGetTransformationCoverageData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'Fully qualified model ID (database.table)',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Transformation coverage details
 */
export const zGetTransformationCoverageResponse = zCoverageDetail;

export const zListScheduledRunsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(
        z.string().register(z.globalRegistry, {
          description: 'Filter by database name',
        })
      ),
    })
  ),
});

/**
 * List of scheduled transformation runs
 */
export const zListScheduledRunsResponse = z
  .object({
    runs: z.array(zScheduledRun),
    total: z.int(),
  })
  .register(z.globalRegistry, {
    description: 'List of scheduled transformation runs',
  });

export const zGetScheduledRunData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string().register(z.globalRegistry, {
      description: 'Fully qualified model ID (database.table)',
    }),
  }),
  query: z.optional(z.never()),
});

/**
 * Scheduled transformation run details
 */
export const zGetScheduledRunResponse = zScheduledRun;

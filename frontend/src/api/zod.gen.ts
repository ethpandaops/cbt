// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod/mini';

/**
 * Lightweight model representation for listings
 */
export const zModelSummary = z.object({
  id: z.string(),
  type: z.enum(['external', 'transformation']),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
});

export const zExternalModel = z.object({
  id: z.string(),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  interval: z.optional(
    z.object({
      type: z.optional(z.string()),
    })
  ),
  cache: z.optional(
    z.object({
      incremental_scan_interval: z.optional(z.string()),
      full_scan_interval: z.optional(z.string()),
    })
  ),
  lag: z.optional(z.int()),
  metadata: z.optional(
    z.readonly(
      z.object({
        created_at: z.optional(z.iso.datetime()),
        updated_at: z.optional(z.iso.datetime()),
        last_synced_at: z.optional(z.iso.datetime()),
        row_count: z.optional(z.int()),
        size_bytes: z.optional(z.int()),
      })
    )
  ),
});

export const zTransformationModelBase = z.object({
  id: z.string(),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  type: z.enum(['scheduled', 'incremental']),
  content_type: z.enum(['sql', 'exec']),
  content: z.string(),
  tags: z.optional(z.array(z.string())),
  depends_on: z.optional(z.array(z.string())),
  metadata: z.optional(
    z.readonly(
      z.object({
        created_at: z.optional(z.iso.datetime()),
        updated_at: z.optional(z.iso.datetime()),
        last_run_at: z.optional(z.iso.datetime()),
        last_run_status: z.optional(z.enum(['success', 'failed', 'running', 'pending'])),
        row_count: z.optional(z.int()),
        size_bytes: z.optional(z.int()),
      })
    )
  ),
});

export const zScheduledTransformation = z.intersection(
  zTransformationModelBase,
  z.object({
    type: z.optional(z.enum(['scheduled'])),
    schedule: z.string(),
  })
);

export const zIncrementalTransformation = z.intersection(
  zTransformationModelBase,
  z.object({
    type: z.optional(z.enum(['incremental'])),
    interval: z.object({
      min: z.int(),
      max: z.int(),
      type: z.string(),
    }),
    schedules: z.optional(
      z.object({
        forwardfill: z.optional(z.string()),
        backfill: z.optional(z.string()),
      })
    ),
    limits: z.optional(
      z.object({
        min: z.optional(z.int()),
        max: z.optional(z.int()),
      })
    ),
  })
);

export const zTransformationModel = z.intersection(
  zTransformationModelBase,
  z.object({
    schedule: z.optional(z.string()),
    interval: z.optional(
      z.object({
        min: z.optional(z.int()),
        max: z.optional(z.int()),
        type: z.optional(z.string()),
      })
    ),
    schedules: z.optional(
      z.object({
        forwardfill: z.optional(z.string()),
        backfill: z.optional(z.string()),
      })
    ),
    limits: z.optional(
      z.object({
        min: z.optional(z.int()),
        max: z.optional(z.int()),
      })
    ),
  })
);

export const zExternalBounds = z.object({
  id: z.string(),
  min: z.int(),
  max: z.int(),
  previous_min: z.optional(z.int()),
  previous_max: z.optional(z.int()),
  last_incremental_scan: z.optional(z.iso.datetime()),
  last_full_scan: z.optional(z.iso.datetime()),
  initial_scan_complete: z.optional(z.boolean()),
  initial_scan_started: z.optional(z.iso.datetime()),
});

export const zRange = z.object({
  position: z.int(),
  interval: z.int(),
});

export const zCoverageSummary = z.object({
  id: z.string(),
  ranges: z.array(zRange),
});

export const zCoverageDetail = z.object({
  id: z.string(),
  ranges: z.array(zRange),
});

export const zScheduledRun = z.object({
  id: z.string(),
  last_run: z.optional(z.iso.datetime()),
});

/**
 * A single transformation step for an interval type
 */
export const zIntervalTypeTransformation = z.object({
  name: z.string(),
  expression: z.optional(z.string()),
  format: z.optional(z.enum(['datetime', 'date', 'time', 'duration', 'relative'])),
});

export const zError = z.object({
  error: z.string(),
  code: z.int(),
});

export const zExternalModelWritable = z.object({
  id: z.string(),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  interval: z.optional(
    z.object({
      type: z.optional(z.string()),
    })
  ),
  cache: z.optional(
    z.object({
      incremental_scan_interval: z.optional(z.string()),
      full_scan_interval: z.optional(z.string()),
    })
  ),
  lag: z.optional(z.int()),
});

export const zTransformationModelBaseWritable = z.object({
  id: z.string(),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  type: z.enum(['scheduled', 'incremental']),
  content_type: z.enum(['sql', 'exec']),
  content: z.string(),
  tags: z.optional(z.array(z.string())),
  depends_on: z.optional(z.array(z.string())),
});

export const zListAllModelsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      type: z.optional(z.enum(['external', 'transformation'])),
      database: z.optional(z.string()),
      search: z.optional(z.string()),
    })
  ),
});

/**
 * List of all models (summary view)
 */
export const zListAllModelsResponse = z.object({
  models: z.array(zModelSummary),
  total: z.int(),
});

export const zListExternalModelsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(z.string()),
    })
  ),
});

/**
 * List of external models
 */
export const zListExternalModelsResponse = z.object({
  models: z.array(zExternalModel),
  total: z.int(),
});

export const zGetExternalModelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * External model details
 */
export const zGetExternalModelResponse = zExternalModel;

export const zListTransformationsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(z.string()),
      type: z.optional(z.enum(['scheduled', 'incremental'])),
      status: z.optional(z.enum(['success', 'failed', 'running', 'pending'])),
    })
  ),
});

/**
 * List of transformation models
 */
export const zListTransformationsResponse = z.object({
  models: z.array(zTransformationModel),
  total: z.int(),
});

export const zGetTransformationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Transformation model details
 */
export const zGetTransformationResponse = zTransformationModel;

export const zListExternalBoundsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * List of external model bounds
 */
export const zListExternalBoundsResponse = z.object({
  bounds: z.array(zExternalBounds),
  total: z.int(),
});

export const zGetExternalBoundsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * External model bounds details
 */
export const zGetExternalBoundsResponse = zExternalBounds;

export const zListTransformationCoverageData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(z.string()),
    })
  ),
});

/**
 * List of transformation coverage
 */
export const zListTransformationCoverageResponse = z.object({
  coverage: z.array(zCoverageSummary),
  total: z.int(),
});

export const zGetTransformationCoverageData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Transformation coverage details
 */
export const zGetTransformationCoverageResponse = zCoverageDetail;

export const zGetIntervalTypesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Interval type transformations
 */
export const zGetIntervalTypesResponse = z.object({
  interval_types: z.record(z.string(), z.array(zIntervalTypeTransformation)),
});

export const zListScheduledRunsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(z.string()),
    })
  ),
});

/**
 * List of scheduled transformation runs
 */
export const zListScheduledRunsResponse = z.object({
  runs: z.array(zScheduledRun),
  total: z.int(),
});

export const zGetScheduledRunData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Scheduled transformation run details
 */
export const zGetScheduledRunResponse = zScheduledRun;

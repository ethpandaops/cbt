// This file is auto-generated by @hey-api/openapi-ts

import * as z from 'zod/mini';

/**
 * Lightweight model representation for listings
 */
export const zModelSummary = z.object({
  id: z.string(),
  type: z.enum(['external', 'transformation']),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
});

export const zExternalModel = z.object({
  id: z.string(),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  interval: z.optional(
    z.object({
      type: z.optional(z.string()),
    })
  ),
  cache: z.optional(
    z.object({
      incremental_scan_interval: z.optional(z.string()),
      full_scan_interval: z.optional(z.string()),
    })
  ),
  lag: z.optional(z.int()),
  metadata: z.optional(
    z.readonly(
      z.object({
        created_at: z.optional(z.iso.datetime()),
        updated_at: z.optional(z.iso.datetime()),
        last_synced_at: z.optional(z.iso.datetime()),
        row_count: z.optional(z.int()),
        size_bytes: z.optional(z.int()),
      })
    )
  ),
});

export const zTransformationModelBase = z.object({
  id: z.string(),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  type: z.enum(['scheduled', 'incremental']),
  content_type: z.enum(['sql', 'exec']),
  content: z.string(),
  tags: z.optional(z.array(z.string())),
  depends_on: z.optional(z.array(z.union([z.string(), z.array(z.string())]))),
  metadata: z.optional(
    z.readonly(
      z.object({
        created_at: z.optional(z.iso.datetime()),
        updated_at: z.optional(z.iso.datetime()),
        last_run_at: z.optional(z.iso.datetime()),
        last_run_status: z.optional(z.enum(['success', 'failed', 'running', 'pending'])),
        row_count: z.optional(z.int()),
        size_bytes: z.optional(z.int()),
      })
    )
  ),
});

export const zScheduledTransformation = z.intersection(
  zTransformationModelBase,
  z.object({
    type: z.optional(z.enum(['scheduled'])),
    schedule: z.string(),
  })
);

export const zIncrementalTransformation = z.intersection(
  zTransformationModelBase,
  z.object({
    type: z.optional(z.enum(['incremental'])),
    interval: z.object({
      min: z.int(),
      max: z.int(),
      type: z.string(),
    }),
    schedules: z.optional(
      z.object({
        forwardfill: z.optional(z.string()),
        backfill: z.optional(z.string()),
      })
    ),
    limits: z.optional(
      z.object({
        min: z.optional(z.int()),
        max: z.optional(z.int()),
      })
    ),
    fill: z.optional(
      z.object({
        direction: z.optional(z.enum(['head', 'tail'])),
        allow_gap_skipping: z.optional(z.boolean()),
        buffer: z.optional(z.int()),
      })
    ),
  })
);

export const zTransformationModel = z.intersection(
  zTransformationModelBase,
  z.object({
    schedule: z.optional(z.string()),
    interval: z.optional(
      z.object({
        min: z.optional(z.int()),
        max: z.optional(z.int()),
        type: z.optional(z.string()),
      })
    ),
    schedules: z.optional(
      z.object({
        forwardfill: z.optional(z.string()),
        backfill: z.optional(z.string()),
      })
    ),
    limits: z.optional(
      z.object({
        min: z.optional(z.int()),
        max: z.optional(z.int()),
      })
    ),
    fill: z.optional(
      z.object({
        direction: z.optional(z.enum(['head', 'tail'])),
        allow_gap_skipping: z.optional(z.boolean()),
        buffer: z.optional(z.int()),
      })
    ),
  })
);

export const zExternalBounds = z.object({
  id: z.string(),
  min: z.int(),
  max: z.int(),
  previous_min: z.optional(z.int()),
  previous_max: z.optional(z.int()),
  last_incremental_scan: z.optional(z.iso.datetime()),
  last_full_scan: z.optional(z.iso.datetime()),
  initial_scan_complete: z.optional(z.boolean()),
  initial_scan_started: z.optional(z.iso.datetime()),
});

export const zRange = z.object({
  position: z.int(),
  interval: z.int(),
});

export const zCoverageSummary = z.object({
  id: z.string(),
  ranges: z.array(zRange),
});

export const zCoverageDetail = z.object({
  id: z.string(),
  ranges: z.array(zRange),
});

export const zScheduledRun = z.object({
  id: z.string(),
  last_run: z.optional(z.iso.datetime()),
});

/**
 * Information about a gap in coverage
 */
export const zGapInfo = z.object({
  start: z.int(),
  end: z.int(),
  size: z.int(),
  overlaps_request: z.optional(z.boolean()),
});

/**
 * Coverage information for the target model itself
 */
export const zModelCoverageInfo = z.object({
  has_data: z.boolean(),
  first_position: z.int(),
  last_end_position: z.int(),
  ranges_in_window: z.optional(z.array(zRange)),
  gaps_in_window: z.optional(z.array(zGapInfo)),
});

/**
 * Position bounds for a model
 */
export const zBoundsInfo = z.object({
  min: z.int(),
  max: z.int(),
  has_data: z.boolean(),
  lag_applied: z.optional(z.int()),
});

/**
 * Debug information for a single dependency
 */
export const zDependencyDebugInfo = z.object({
  id: z.string(),
  type: z.enum(['required', 'or_group']),
  node_type: z.enum(['external', 'transformation']),
  is_incremental: z.optional(z.boolean()),
  bounds: zBoundsInfo,
  gaps: z.optional(z.array(zGapInfo)),
  coverage_status: z.optional(z.enum(['full_coverage', 'has_gaps', 'no_data', 'not_initialized'])),
  blocking: z.optional(z.boolean()),
  get or_group_members(): z.ZodMiniOptional {
    return z.optional(
      z.array(
        z.lazy((): any => {
          return zDependencyDebugInfo;
        })
      )
    );
  },
  get child_dependencies(): z.ZodMiniOptional {
    return z.optional(
      z.array(
        z.lazy((): any => {
          return zDependencyDebugInfo;
        })
      )
    );
  },
});

/**
 * Validation results using the same logic as backfill/dependency checking
 */
export const zValidationDebugInfo = z.object({
  in_bounds: z.boolean(),
  valid_range: z.optional(
    z.object({
      min: z.int(),
      max: z.int(),
    })
  ),
  has_dependency_gaps: z.boolean(),
  blocking_gaps: z.optional(
    z.array(
      z.object({
        dependency_id: z.string(),
        gap: zGapInfo,
      })
    )
  ),
  next_valid_position: z.optional(z.int()),
  reasons: z.optional(z.array(z.string())),
});

/**
 * Comprehensive debug information for coverage and dependencies at a specific position
 */
export const zCoverageDebug = z.object({
  model_id: z.string(),
  position: z.int(),
  interval: z.int(),
  end_position: z.optional(z.int()),
  can_process: z.boolean(),
  model_coverage: zModelCoverageInfo,
  dependencies: z.array(zDependencyDebugInfo),
  validation: zValidationDebugInfo,
});

/**
 * A single transformation step for an interval type
 */
export const zIntervalTypeTransformation = z.object({
  name: z.string(),
  expression: z.optional(z.string()),
  format: z.optional(z.enum(['datetime', 'date', 'time', 'duration', 'relative'])),
});

export const zError = z.object({
  error: z.string(),
  code: z.int(),
});

export const zExternalModelWritable = z.object({
  id: z.string(),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  interval: z.optional(
    z.object({
      type: z.optional(z.string()),
    })
  ),
  cache: z.optional(
    z.object({
      incremental_scan_interval: z.optional(z.string()),
      full_scan_interval: z.optional(z.string()),
    })
  ),
  lag: z.optional(z.int()),
});

export const zTransformationModelBaseWritable = z.object({
  id: z.string(),
  database: z.string(),
  table: z.string(),
  description: z.optional(z.string()),
  type: z.enum(['scheduled', 'incremental']),
  content_type: z.enum(['sql', 'exec']),
  content: z.string(),
  tags: z.optional(z.array(z.string())),
  depends_on: z.optional(z.array(z.union([z.string(), z.array(z.string())]))),
});

export const zListAllModelsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      type: z.optional(z.enum(['external', 'transformation'])),
      database: z.optional(z.string()),
      search: z.optional(z.string()),
    })
  ),
});

/**
 * List of all models (summary view)
 */
export const zListAllModelsResponse = z.object({
  models: z.array(zModelSummary),
  total: z.int(),
});

export const zListExternalModelsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(z.string()),
    })
  ),
});

/**
 * List of external models
 */
export const zListExternalModelsResponse = z.object({
  models: z.array(zExternalModel),
  total: z.int(),
});

export const zGetExternalModelData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * External model details
 */
export const zGetExternalModelResponse = zExternalModel;

export const zListTransformationsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(z.string()),
      type: z.optional(z.enum(['scheduled', 'incremental'])),
      status: z.optional(z.enum(['success', 'failed', 'running', 'pending'])),
    })
  ),
});

/**
 * List of transformation models
 */
export const zListTransformationsResponse = z.object({
  models: z.array(zTransformationModel),
  total: z.int(),
});

export const zGetTransformationData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Transformation model details
 */
export const zGetTransformationResponse = zTransformationModel;

export const zListExternalBoundsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * List of external model bounds
 */
export const zListExternalBoundsResponse = z.object({
  bounds: z.array(zExternalBounds),
  total: z.int(),
});

export const zGetExternalBoundsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * External model bounds details
 */
export const zGetExternalBoundsResponse = zExternalBounds;

export const zListTransformationCoverageData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(z.string()),
    })
  ),
});

/**
 * List of transformation coverage
 */
export const zListTransformationCoverageResponse = z.object({
  coverage: z.array(zCoverageSummary),
  total: z.int(),
});

export const zGetTransformationCoverageData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Transformation coverage details
 */
export const zGetTransformationCoverageResponse = zCoverageDetail;

export const zDebugCoverageAtPositionData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
    position: z.int(),
  }),
  query: z.optional(z.never()),
});

/**
 * Detailed coverage debug information
 */
export const zDebugCoverageAtPositionResponse = zCoverageDebug;

export const zGetIntervalTypesData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Interval type transformations
 */
export const zGetIntervalTypesResponse = z.object({
  interval_types: z.record(z.string(), z.array(zIntervalTypeTransformation)),
});

export const zListScheduledRunsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(
    z.object({
      database: z.optional(z.string()),
    })
  ),
});

/**
 * List of scheduled transformation runs
 */
export const zListScheduledRunsResponse = z.object({
  runs: z.array(zScheduledRun),
  total: z.int(),
});

export const zGetScheduledRunData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Scheduled transformation run details
 */
export const zGetScheduledRunResponse = zScheduledRun;

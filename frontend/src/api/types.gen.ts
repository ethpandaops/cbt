// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: 'http://localhost:8080/api/v1' | (string & {});
};

/**
 * Lightweight model representation for listings
 */
export type ModelSummary = {
  /**
   * Fully qualified ID (database.table)
   */
  id: string;
  /**
   * Model type
   */
  type: 'external' | 'transformation';
  database: string;
  table: string;
  description?: string;
};

export type ExternalModel = {
  /**
   * Fully qualified ID (database.table)
   */
  id: string;
  database: string;
  table: string;
  description?: string;
  /**
   * Interval configuration for external source
   */
  interval?: {
    /**
     * Type of interval (e.g., "second", "slot", "epoch", "block")
     */
    type?: string;
  };
  /**
   * Cache configuration for external source
   */
  cache?: {
    /**
     * Interval for incremental cache updates
     */
    incremental_scan_interval?: string;
    /**
     * Interval for full cache refresh
     */
    full_scan_interval?: string;
  };
  /**
   * Number of blocks/slots to lag behind head
   */
  lag?: number;
  /**
   * System-managed metadata
   */
  readonly metadata?: {
    created_at?: string;
    updated_at?: string;
    last_synced_at?: string;
    /**
     * Approximate row count in destination table
     */
    row_count?: number;
    /**
     * Approximate table size in bytes
     */
    size_bytes?: number;
  };
};

export type TransformationModelBase = {
  /**
   * Fully qualified ID (database.table)
   */
  id: string;
  database: string;
  table: string;
  description?: string;
  /**
   * Transformation type (scheduled or incremental)
   */
  type: 'scheduled' | 'incremental';
  /**
   * Execution method (SQL query or shell command)
   */
  content_type: 'sql' | 'exec';
  /**
   * SQL query or exec command defining the transformation
   */
  content: string;
  /**
   * Tags for categorization
   */
  tags?: Array<string>;
  /**
   * Upstream model dependencies preserving AND/OR semantics.
   * - String elements represent required dependencies (AND logic)
   * - Array elements represent OR groups (at least one required)
   *
   */
  depends_on?: Array<string | Array<string>>;
  /**
   * System-managed metadata
   */
  readonly metadata?: {
    created_at?: string;
    updated_at?: string;
    last_run_at?: string;
    last_run_status?: 'success' | 'failed' | 'running' | 'pending';
    row_count?: number;
    size_bytes?: number;
  };
};

export type ScheduledTransformation = TransformationModelBase & {
  type?: 'scheduled';
  /**
   * Cron expression (REQUIRED for scheduled type)
   */
  schedule: string;
};

export type IncrementalTransformation = TransformationModelBase & {
  type?: 'incremental';
  /**
   * Interval configuration (REQUIRED for incremental type)
   */
  interval: {
    /**
     * Minimum interval size (0 = allow any partial size)
     */
    min: number;
    /**
     * Maximum interval size for processing
     */
    max: number;
    /**
     * Type of interval (e.g., "second", "slot", "epoch", "block")
     */
    type: string;
  };
  /**
   * Forwardfill and backfill schedules (for incremental type)
   */
  schedules?: {
    /**
     * Forward fill schedule
     */
    forwardfill?: string;
    /**
     * Backfill schedule
     */
    backfill?: string;
  };
  /**
   * Position limits for incremental processing
   */
  limits?: {
    /**
     * Minimum position limit
     */
    min?: number;
    /**
     * Maximum position limit
     */
    max?: number;
  };
  /**
   * Fill behavior configuration for incremental processing
   */
  fill?: {
    /**
     * Fill direction (head or tail)
     */
    direction?: 'head' | 'tail';
    /**
     * Whether to allow skipping gaps in dependency data
     */
    allow_gap_skipping?: boolean;
    /**
     * Stay N positions behind dependency max (0 = no buffer)
     */
    buffer?: number;
  };
};

export type TransformationModel = TransformationModelBase & {
  /**
   * Cron expression (present when type=scheduled)
   */
  schedule?: string;
  /**
   * Interval configuration (present when type=incremental)
   */
  interval?: {
    /**
     * Minimum interval size
     */
    min?: number;
    /**
     * Maximum interval size
     */
    max?: number;
    /**
     * Type of interval (e.g., "second", "slot", "epoch", "block")
     */
    type?: string;
  };
  /**
   * Schedules (present when type=incremental)
   */
  schedules?: {
    /**
     * Forward fill schedule
     */
    forwardfill?: string;
    /**
     * Backfill schedule
     */
    backfill?: string;
  };
  /**
   * Limits (present when type=incremental)
   */
  limits?: {
    /**
     * Minimum position limit
     */
    min?: number;
    /**
     * Maximum position limit
     */
    max?: number;
  };
  /**
   * Fill behavior (present when type=incremental)
   */
  fill?: {
    /**
     * Fill direction (head or tail)
     */
    direction?: 'head' | 'tail';
    /**
     * Whether to allow skipping gaps in dependency data
     */
    allow_gap_skipping?: boolean;
    /**
     * Stay N positions behind dependency max (0 = no buffer)
     */
    buffer?: number;
  };
};

export type ExternalBounds = {
  /**
   * Fully qualified model ID (database.table)
   */
  id: string;
  /**
   * Minimum position in external source
   */
  min: number;
  /**
   * Maximum position in external source
   */
  max: number;
  /**
   * Previous minimum position (for tracking changes)
   */
  previous_min?: number;
  /**
   * Previous maximum position (for tracking changes)
   */
  previous_max?: number;
  /**
   * Timestamp of last incremental scan
   */
  last_incremental_scan?: string;
  /**
   * Timestamp of last full scan
   */
  last_full_scan?: string;
  /**
   * Whether initial scan is complete
   */
  initial_scan_complete?: boolean;
  /**
   * Timestamp when initial scan started
   */
  initial_scan_started?: string;
};

export type Range = {
  /**
   * Starting position of processed range
   */
  position: number;
  /**
   * Size of processed range
   */
  interval: number;
};

export type CoverageSummary = {
  /**
   * Fully qualified model ID (database.table)
   */
  id: string;
  /**
   * Processed ranges from admin_incremental table
   */
  ranges: Array<Range>;
};

export type CoverageDetail = {
  /**
   * Fully qualified model ID (database.table)
   */
  id: string;
  /**
   * All processed ranges from admin_incremental table
   */
  ranges: Array<Range>;
};

export type ScheduledRun = {
  /**
   * Fully qualified model ID (database.table)
   */
  id: string;
  /**
   * Timestamp of last execution
   */
  last_run?: string;
};

/**
 * Comprehensive debug information for coverage and dependencies at a specific position
 */
export type CoverageDebug = {
  /**
   * The model being debugged
   */
  model_id: string;
  /**
   * Position being checked
   */
  position: number;
  /**
   * Interval size checked
   */
  interval: number;
  /**
   * End position (position + interval)
   */
  end_position?: number;
  /**
   * Whether this position can be processed
   */
  can_process: boolean;
  model_coverage: ModelCoverageInfo;
  /**
   * Recursive dependency analysis
   */
  dependencies: Array<DependencyDebugInfo>;
  validation: ValidationDebugInfo;
};

/**
 * Coverage information for the target model itself
 */
export type ModelCoverageInfo = {
  /**
   * Whether model has any processed data
   */
  has_data: boolean;
  /**
   * First processed position
   */
  first_position: number;
  /**
   * Last processed end position (max(position + interval))
   */
  last_end_position: number;
  /**
   * Processed ranges overlapping the requested position window
   */
  ranges_in_window?: Array<Range>;
  /**
   * Gaps detected in the requested position window
   */
  gaps_in_window?: Array<GapInfo>;
};

/**
 * Debug information for a single dependency
 */
export type DependencyDebugInfo = {
  /**
   * Dependency model ID
   */
  id: string;
  /**
   * Dependency type (AND or OR group)
   */
  type: 'required' | 'or_group';
  /**
   * Type of dependency model
   */
  node_type: 'external' | 'transformation';
  /**
   * Whether this is an incremental transformation (can have gaps)
   */
  is_incremental?: boolean;
  bounds: BoundsInfo;
  /**
   * Gaps found in this dependency for the requested range
   */
  gaps?: Array<GapInfo>;
  /**
   * Coverage status for the requested position
   */
  coverage_status?: 'full_coverage' | 'has_gaps' | 'no_data' | 'not_initialized';
  /**
   * Whether this dependency is blocking processing
   */
  blocking?: boolean;
  /**
   * For OR groups, debug info for each member
   */
  or_group_members?: Array<DependencyDebugInfo>;
  /**
   * Recursive dependencies of this dependency
   */
  child_dependencies?: Array<DependencyDebugInfo>;
};

/**
 * Position bounds for a model
 */
export type BoundsInfo = {
  /**
   * Minimum available position
   */
  min: number;
  /**
   * Maximum available position (for external) or last processed end (for transformation)
   */
  max: number;
  /**
   * Whether the model has any data
   */
  has_data: boolean;
  /**
   * Lag applied to external model (if applicable)
   */
  lag_applied?: number;
};

/**
 * Information about a gap in coverage
 */
export type GapInfo = {
  /**
   * Gap start position
   */
  start: number;
  /**
   * Gap end position
   */
  end: number;
  /**
   * Gap size in interval units
   */
  size: number;
  /**
   * Whether this gap overlaps with the requested position range
   */
  overlaps_request?: boolean;
};

/**
 * Validation results using the same logic as backfill/dependency checking
 */
export type ValidationDebugInfo = {
  /**
   * Whether position is within valid bounds of all dependencies
   */
  in_bounds: boolean;
  /**
   * Valid position range calculated from dependencies
   */
  valid_range?: {
    min: number;
    max: number;
  };
  /**
   * Whether any dependencies have gaps in the requested range
   */
  has_dependency_gaps: boolean;
  /**
   * List of gaps blocking processing
   */
  blocking_gaps?: Array<{
    dependency_id: string;
    gap: GapInfo;
  }>;
  /**
   * Next position where dependencies are available (if blocked)
   */
  next_valid_position?: number;
  /**
   * Human-readable reasons why position cannot be processed
   */
  reasons?: Array<string>;
};

/**
 * A single transformation step for an interval type
 */
export type IntervalTypeTransformation = {
  /**
   * Display name for this transformation
   */
  name: string;
  /**
   * Optional CEL (Common Expression Language) expression to transform the value.
   * Uses 'value' as the input variable.
   * Supports math functions via math.* namespace (e.g., math.floor, math.ceil, math.round).
   * If omitted, value is passed through unchanged (identity transformation).
   *
   */
  expression?: string;
  /**
   * Optional display format hint for the frontend.
   * - datetime: Format as full date and time (e.g., "2024-01-15 14:30:00")
   * - date: Format as date only (e.g., "2024-01-15")
   * - time: Format as time only (e.g., "14:30:00")
   * - duration: Format as human-readable duration (e.g., "2h 30m")
   * - relative: Format as relative time (e.g., "2 hours ago")
   * If omitted, value is displayed as a raw number.
   *
   */
  format?: 'datetime' | 'date' | 'time' | 'duration' | 'relative';
};

export type _Error = {
  /**
   * Human-readable error message
   */
  error: string;
  /**
   * HTTP status code
   */
  code: number;
};

export type ExternalModelWritable = {
  /**
   * Fully qualified ID (database.table)
   */
  id: string;
  database: string;
  table: string;
  description?: string;
  /**
   * Interval configuration for external source
   */
  interval?: {
    /**
     * Type of interval (e.g., "second", "slot", "epoch", "block")
     */
    type?: string;
  };
  /**
   * Cache configuration for external source
   */
  cache?: {
    /**
     * Interval for incremental cache updates
     */
    incremental_scan_interval?: string;
    /**
     * Interval for full cache refresh
     */
    full_scan_interval?: string;
  };
  /**
   * Number of blocks/slots to lag behind head
   */
  lag?: number;
};

export type TransformationModelBaseWritable = {
  /**
   * Fully qualified ID (database.table)
   */
  id: string;
  database: string;
  table: string;
  description?: string;
  /**
   * Transformation type (scheduled or incremental)
   */
  type: 'scheduled' | 'incremental';
  /**
   * Execution method (SQL query or shell command)
   */
  content_type: 'sql' | 'exec';
  /**
   * SQL query or exec command defining the transformation
   */
  content: string;
  /**
   * Tags for categorization
   */
  tags?: Array<string>;
  /**
   * Upstream model dependencies preserving AND/OR semantics.
   * - String elements represent required dependencies (AND logic)
   * - Array elements represent OR groups (at least one required)
   *
   */
  depends_on?: Array<string | Array<string>>;
};

export type ListAllModelsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by model type
     */
    type?: 'external' | 'transformation';
    /**
     * Filter by database name
     */
    database?: string;
    /**
     * Search by model ID or description (case-insensitive)
     */
    search?: string;
  };
  url: '/models';
};

export type ListAllModelsErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type ListAllModelsError = ListAllModelsErrors[keyof ListAllModelsErrors];

export type ListAllModelsResponses = {
  /**
   * List of all models (summary view)
   */
  200: {
    models: Array<ModelSummary>;
    total: number;
  };
};

export type ListAllModelsResponse = ListAllModelsResponses[keyof ListAllModelsResponses];

export type ListExternalModelsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by database name
     */
    database?: string;
  };
  url: '/models/external';
};

export type ListExternalModelsErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type ListExternalModelsError = ListExternalModelsErrors[keyof ListExternalModelsErrors];

export type ListExternalModelsResponses = {
  /**
   * List of external models
   */
  200: {
    models: Array<ExternalModel>;
    total: number;
  };
};

export type ListExternalModelsResponse = ListExternalModelsResponses[keyof ListExternalModelsResponses];

export type GetExternalModelData = {
  body?: never;
  path: {
    /**
     * Fully qualified model ID (database.table)
     */
    id: string;
  };
  query?: never;
  url: '/models/external/{id}';
};

export type GetExternalModelErrors = {
  /**
   * Resource not found
   */
  404: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetExternalModelError = GetExternalModelErrors[keyof GetExternalModelErrors];

export type GetExternalModelResponses = {
  /**
   * External model details
   */
  200: ExternalModel;
};

export type GetExternalModelResponse = GetExternalModelResponses[keyof GetExternalModelResponses];

export type ListTransformationsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by database name
     */
    database?: string;
    /**
     * Filter by transformation type
     */
    type?: 'scheduled' | 'incremental';
    /**
     * Filter by last run status
     */
    status?: 'success' | 'failed' | 'running' | 'pending';
  };
  url: '/models/transformations';
};

export type ListTransformationsErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type ListTransformationsError = ListTransformationsErrors[keyof ListTransformationsErrors];

export type ListTransformationsResponses = {
  /**
   * List of transformation models
   */
  200: {
    models: Array<TransformationModel>;
    total: number;
  };
};

export type ListTransformationsResponse = ListTransformationsResponses[keyof ListTransformationsResponses];

export type GetTransformationData = {
  body?: never;
  path: {
    /**
     * Fully qualified model ID (database.table)
     */
    id: string;
  };
  query?: never;
  url: '/models/transformations/{id}';
};

export type GetTransformationErrors = {
  /**
   * Resource not found
   */
  404: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetTransformationError = GetTransformationErrors[keyof GetTransformationErrors];

export type GetTransformationResponses = {
  /**
   * Transformation model details
   */
  200: TransformationModel;
};

export type GetTransformationResponse = GetTransformationResponses[keyof GetTransformationResponses];

export type ListExternalBoundsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/models/external/bounds';
};

export type ListExternalBoundsErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type ListExternalBoundsError = ListExternalBoundsErrors[keyof ListExternalBoundsErrors];

export type ListExternalBoundsResponses = {
  /**
   * List of external model bounds
   */
  200: {
    bounds: Array<ExternalBounds>;
    total: number;
  };
};

export type ListExternalBoundsResponse = ListExternalBoundsResponses[keyof ListExternalBoundsResponses];

export type GetExternalBoundsData = {
  body?: never;
  path: {
    /**
     * Fully qualified model ID (database.table)
     */
    id: string;
  };
  query?: never;
  url: '/models/external/{id}/bounds';
};

export type GetExternalBoundsErrors = {
  /**
   * Resource not found
   */
  404: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetExternalBoundsError = GetExternalBoundsErrors[keyof GetExternalBoundsErrors];

export type GetExternalBoundsResponses = {
  /**
   * External model bounds details
   */
  200: ExternalBounds;
};

export type GetExternalBoundsResponse = GetExternalBoundsResponses[keyof GetExternalBoundsResponses];

export type ListTransformationCoverageData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by database name
     */
    database?: string;
  };
  url: '/models/transformations/coverage';
};

export type ListTransformationCoverageErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type ListTransformationCoverageError = ListTransformationCoverageErrors[keyof ListTransformationCoverageErrors];

export type ListTransformationCoverageResponses = {
  /**
   * List of transformation coverage
   */
  200: {
    coverage: Array<CoverageSummary>;
    total: number;
  };
};

export type ListTransformationCoverageResponse =
  ListTransformationCoverageResponses[keyof ListTransformationCoverageResponses];

export type GetTransformationCoverageData = {
  body?: never;
  path: {
    /**
     * Fully qualified model ID (database.table)
     */
    id: string;
  };
  query?: never;
  url: '/models/transformations/{id}/coverage';
};

export type GetTransformationCoverageErrors = {
  /**
   * Model is not incremental type
   */
  400: _Error;
  /**
   * Resource not found
   */
  404: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetTransformationCoverageError = GetTransformationCoverageErrors[keyof GetTransformationCoverageErrors];

export type GetTransformationCoverageResponses = {
  /**
   * Transformation coverage details
   */
  200: CoverageDetail;
};

export type GetTransformationCoverageResponse =
  GetTransformationCoverageResponses[keyof GetTransformationCoverageResponses];

export type DebugCoverageAtPositionData = {
  body?: never;
  path: {
    /**
     * Fully qualified model ID (database.table)
     */
    id: string;
    /**
     * Position to debug
     */
    position: number;
  };
  query?: never;
  url: '/models/transformations/{id}/coverage/{position}';
};

export type DebugCoverageAtPositionErrors = {
  /**
   * Model is not incremental type
   */
  400: _Error;
  /**
   * Resource not found
   */
  404: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type DebugCoverageAtPositionError = DebugCoverageAtPositionErrors[keyof DebugCoverageAtPositionErrors];

export type DebugCoverageAtPositionResponses = {
  /**
   * Detailed coverage debug information
   */
  200: CoverageDebug;
};

export type DebugCoverageAtPositionResponse = DebugCoverageAtPositionResponses[keyof DebugCoverageAtPositionResponses];

export type GetIntervalTypesData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/interval/types';
};

export type GetIntervalTypesErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetIntervalTypesError = GetIntervalTypesErrors[keyof GetIntervalTypesErrors];

export type GetIntervalTypesResponses = {
  /**
   * Interval type transformations
   */
  200: {
    interval_types: {
      [key: string]: Array<IntervalTypeTransformation>;
    };
  };
};

export type GetIntervalTypesResponse = GetIntervalTypesResponses[keyof GetIntervalTypesResponses];

export type ListScheduledRunsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by database name
     */
    database?: string;
  };
  url: '/models/transformations/runs';
};

export type ListScheduledRunsErrors = {
  /**
   * Internal server error
   */
  500: _Error;
};

export type ListScheduledRunsError = ListScheduledRunsErrors[keyof ListScheduledRunsErrors];

export type ListScheduledRunsResponses = {
  /**
   * List of scheduled transformation runs
   */
  200: {
    runs: Array<ScheduledRun>;
    total: number;
  };
};

export type ListScheduledRunsResponse = ListScheduledRunsResponses[keyof ListScheduledRunsResponses];

export type GetScheduledRunData = {
  body?: never;
  path: {
    /**
     * Fully qualified model ID (database.table)
     */
    id: string;
  };
  query?: never;
  url: '/models/transformations/{id}/runs';
};

export type GetScheduledRunErrors = {
  /**
   * Model is not scheduled type
   */
  400: _Error;
  /**
   * Resource not found
   */
  404: _Error;
  /**
   * Internal server error
   */
  500: _Error;
};

export type GetScheduledRunError = GetScheduledRunErrors[keyof GetScheduledRunErrors];

export type GetScheduledRunResponses = {
  /**
   * Scheduled transformation run details
   */
  200: ScheduledRun;
};

export type GetScheduledRunResponse = GetScheduledRunResponses[keyof GetScheduledRunResponses];

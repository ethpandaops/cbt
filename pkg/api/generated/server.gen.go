// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gofiber/fiber/v3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for DependencyDebugInfoCoverageStatus.
const (
	FullCoverage   DependencyDebugInfoCoverageStatus = "full_coverage"
	HasGaps        DependencyDebugInfoCoverageStatus = "has_gaps"
	NoData         DependencyDebugInfoCoverageStatus = "no_data"
	NotInitialized DependencyDebugInfoCoverageStatus = "not_initialized"
)

// Defines values for DependencyDebugInfoNodeType.
const (
	DependencyDebugInfoNodeTypeExternal       DependencyDebugInfoNodeType = "external"
	DependencyDebugInfoNodeTypeTransformation DependencyDebugInfoNodeType = "transformation"
)

// Defines values for DependencyDebugInfoType.
const (
	OrGroup  DependencyDebugInfoType = "or_group"
	Required DependencyDebugInfoType = "required"
)

// Defines values for IntervalTypeTransformationFormat.
const (
	Date     IntervalTypeTransformationFormat = "date"
	Datetime IntervalTypeTransformationFormat = "datetime"
	Duration IntervalTypeTransformationFormat = "duration"
	Relative IntervalTypeTransformationFormat = "relative"
	Time     IntervalTypeTransformationFormat = "time"
)

// Defines values for ModelSummaryType.
const (
	ModelSummaryTypeExternal       ModelSummaryType = "external"
	ModelSummaryTypeTransformation ModelSummaryType = "transformation"
)

// Defines values for TransformationModelContentType.
const (
	TransformationModelContentTypeExec TransformationModelContentType = "exec"
	TransformationModelContentTypeSql  TransformationModelContentType = "sql"
)

// Defines values for TransformationModelMetadataLastRunStatus.
const (
	TransformationModelMetadataLastRunStatusFailed  TransformationModelMetadataLastRunStatus = "failed"
	TransformationModelMetadataLastRunStatusPending TransformationModelMetadataLastRunStatus = "pending"
	TransformationModelMetadataLastRunStatusRunning TransformationModelMetadataLastRunStatus = "running"
	TransformationModelMetadataLastRunStatusSuccess TransformationModelMetadataLastRunStatus = "success"
)

// Defines values for TransformationModelType.
const (
	TransformationModelTypeIncremental TransformationModelType = "incremental"
	TransformationModelTypeScheduled   TransformationModelType = "scheduled"
)

// Defines values for TransformationModelBaseContentType.
const (
	TransformationModelBaseContentTypeExec TransformationModelBaseContentType = "exec"
	TransformationModelBaseContentTypeSql  TransformationModelBaseContentType = "sql"
)

// Defines values for TransformationModelBaseMetadataLastRunStatus.
const (
	TransformationModelBaseMetadataLastRunStatusFailed  TransformationModelBaseMetadataLastRunStatus = "failed"
	TransformationModelBaseMetadataLastRunStatusPending TransformationModelBaseMetadataLastRunStatus = "pending"
	TransformationModelBaseMetadataLastRunStatusRunning TransformationModelBaseMetadataLastRunStatus = "running"
	TransformationModelBaseMetadataLastRunStatusSuccess TransformationModelBaseMetadataLastRunStatus = "success"
)

// Defines values for TransformationModelBaseType.
const (
	TransformationModelBaseTypeIncremental TransformationModelBaseType = "incremental"
	TransformationModelBaseTypeScheduled   TransformationModelBaseType = "scheduled"
)

// Defines values for ListAllModelsParamsType.
const (
	External       ListAllModelsParamsType = "external"
	Transformation ListAllModelsParamsType = "transformation"
)

// Defines values for ListTransformationsParamsType.
const (
	Incremental ListTransformationsParamsType = "incremental"
	Scheduled   ListTransformationsParamsType = "scheduled"
)

// Defines values for ListTransformationsParamsStatus.
const (
	Failed  ListTransformationsParamsStatus = "failed"
	Pending ListTransformationsParamsStatus = "pending"
	Running ListTransformationsParamsStatus = "running"
	Success ListTransformationsParamsStatus = "success"
)

// BoundsInfo Position bounds for a model
type BoundsInfo struct {
	// HasData Whether the model has any data
	HasData bool `json:"has_data"`

	// LagApplied Lag applied to external model (if applicable)
	LagApplied *int `json:"lag_applied,omitempty"`

	// Max Maximum available position (for external) or last processed end (for transformation)
	Max int `json:"max"`

	// Min Minimum available position
	Min int `json:"min"`
}

// CoverageDebug Comprehensive debug information for coverage and dependencies at a specific position
type CoverageDebug struct {
	// CanProcess Whether this position can be processed
	CanProcess bool `json:"can_process"`

	// Dependencies Recursive dependency analysis
	Dependencies []DependencyDebugInfo `json:"dependencies"`

	// EndPosition End position (position + interval)
	EndPosition *int `json:"end_position,omitempty"`

	// Interval Interval size checked
	Interval int `json:"interval"`

	// ModelCoverage Coverage information for the target model itself
	ModelCoverage ModelCoverageInfo `json:"model_coverage"`

	// ModelId The model being debugged
	ModelId string `json:"model_id"`

	// Position Position being checked
	Position int `json:"position"`

	// Validation Validation results using the same logic as backfill/dependency checking
	Validation ValidationDebugInfo `json:"validation"`
}

// CoverageDetail defines model for CoverageDetail.
type CoverageDetail struct {
	// Id Fully qualified model ID (database.table)
	Id string `json:"id"`

	// Ranges All processed ranges from admin_incremental table
	Ranges []Range `json:"ranges"`
}

// CoverageSummary defines model for CoverageSummary.
type CoverageSummary struct {
	// Id Fully qualified model ID (database.table)
	Id string `json:"id"`

	// Ranges Processed ranges from admin_incremental table
	Ranges []Range `json:"ranges"`
}

// DependencyDebugInfo Debug information for a single dependency
type DependencyDebugInfo struct {
	// Blocking Whether this dependency is blocking processing
	Blocking *bool `json:"blocking,omitempty"`

	// Bounds Position bounds for a model
	Bounds BoundsInfo `json:"bounds"`

	// ChildDependencies Recursive dependencies of this dependency
	ChildDependencies *[]DependencyDebugInfo `json:"child_dependencies,omitempty"`

	// CoverageStatus Coverage status for the requested position
	CoverageStatus *DependencyDebugInfoCoverageStatus `json:"coverage_status,omitempty"`

	// Gaps Gaps found in this dependency for the requested range
	Gaps *[]GapInfo `json:"gaps,omitempty"`

	// Id Dependency model ID
	Id string `json:"id"`

	// IsIncremental Whether this is an incremental transformation (can have gaps)
	IsIncremental *bool `json:"is_incremental,omitempty"`

	// NodeType Type of dependency model
	NodeType DependencyDebugInfoNodeType `json:"node_type"`

	// OrGroupMembers For OR groups, debug info for each member
	OrGroupMembers *[]DependencyDebugInfo `json:"or_group_members,omitempty"`

	// Type Dependency type (AND or OR group)
	Type DependencyDebugInfoType `json:"type"`
}

// DependencyDebugInfoCoverageStatus Coverage status for the requested position
type DependencyDebugInfoCoverageStatus string

// DependencyDebugInfoNodeType Type of dependency model
type DependencyDebugInfoNodeType string

// DependencyDebugInfoType Dependency type (AND or OR group)
type DependencyDebugInfoType string

// Error defines model for Error.
type Error struct {
	// Code HTTP status code
	Code int `json:"code"`

	// Error Human-readable error message
	Error string `json:"error"`
}

// ExternalBounds defines model for ExternalBounds.
type ExternalBounds struct {
	// Id Fully qualified model ID (database.table)
	Id string `json:"id"`

	// InitialScanComplete Whether initial scan is complete
	InitialScanComplete *bool `json:"initial_scan_complete,omitempty"`

	// InitialScanStarted Timestamp when initial scan started
	InitialScanStarted *time.Time `json:"initial_scan_started,omitempty"`

	// LastFullScan Timestamp of last full scan
	LastFullScan *time.Time `json:"last_full_scan,omitempty"`

	// LastIncrementalScan Timestamp of last incremental scan
	LastIncrementalScan *time.Time `json:"last_incremental_scan,omitempty"`

	// Max Maximum position in external source
	Max int `json:"max"`

	// Min Minimum position in external source
	Min int `json:"min"`

	// PreviousMax Previous maximum position (for tracking changes)
	PreviousMax *int `json:"previous_max,omitempty"`

	// PreviousMin Previous minimum position (for tracking changes)
	PreviousMin *int `json:"previous_min,omitempty"`
}

// ExternalModel defines model for ExternalModel.
type ExternalModel struct {
	// Cache Cache configuration for external source
	Cache *struct {
		// FullScanInterval Interval for full cache refresh
		FullScanInterval *string `json:"full_scan_interval,omitempty"`

		// IncrementalScanInterval Interval for incremental cache updates
		IncrementalScanInterval *string `json:"incremental_scan_interval,omitempty"`
	} `json:"cache,omitempty"`
	Database    string  `json:"database"`
	Description *string `json:"description,omitempty"`

	// Id Fully qualified ID (database.table)
	Id string `json:"id"`

	// Interval Interval configuration for external source
	Interval *struct {
		// Type Type of interval (e.g., "second", "slot", "epoch", "block")
		Type *string `json:"type,omitempty"`
	} `json:"interval,omitempty"`

	// Lag Number of blocks/slots to lag behind head
	Lag *int `json:"lag,omitempty"`

	// Metadata System-managed metadata
	Metadata *struct {
		CreatedAt    *time.Time `json:"created_at,omitempty"`
		LastSyncedAt *time.Time `json:"last_synced_at,omitempty"`

		// RowCount Approximate row count in destination table
		RowCount *int `json:"row_count,omitempty"`

		// SizeBytes Approximate table size in bytes
		SizeBytes *int       `json:"size_bytes,omitempty"`
		UpdatedAt *time.Time `json:"updated_at,omitempty"`
	} `json:"metadata,omitempty"`
	Table string `json:"table"`
}

// GapInfo Information about a gap in coverage
type GapInfo struct {
	// End Gap end position
	End int `json:"end"`

	// OverlapsRequest Whether this gap overlaps with the requested position range
	OverlapsRequest *bool `json:"overlaps_request,omitempty"`

	// Size Gap size in interval units
	Size int `json:"size"`

	// Start Gap start position
	Start int `json:"start"`
}

// IntervalTypeTransformation A single transformation step for an interval type
type IntervalTypeTransformation struct {
	// Expression Optional CEL (Common Expression Language) expression to transform the value.
	// Uses 'value' as the input variable.
	// Supports math functions via math.* namespace (e.g., math.floor, math.ceil, math.round).
	// If omitted, value is passed through unchanged (identity transformation).
	Expression *string `json:"expression,omitempty"`

	// Format Optional display format hint for the frontend.
	// - datetime: Format as full date and time (e.g., "2024-01-15 14:30:00")
	// - date: Format as date only (e.g., "2024-01-15")
	// - time: Format as time only (e.g., "14:30:00")
	// - duration: Format as human-readable duration (e.g., "2h 30m")
	// - relative: Format as relative time (e.g., "2 hours ago")
	// If omitted, value is displayed as a raw number.
	Format *IntervalTypeTransformationFormat `json:"format,omitempty"`

	// Name Display name for this transformation
	Name string `json:"name"`
}

// IntervalTypeTransformationFormat Optional display format hint for the frontend.
// - datetime: Format as full date and time (e.g., "2024-01-15 14:30:00")
// - date: Format as date only (e.g., "2024-01-15")
// - time: Format as time only (e.g., "14:30:00")
// - duration: Format as human-readable duration (e.g., "2h 30m")
// - relative: Format as relative time (e.g., "2 hours ago")
// If omitted, value is displayed as a raw number.
type IntervalTypeTransformationFormat string

// ModelCoverageInfo Coverage information for the target model itself
type ModelCoverageInfo struct {
	// FirstPosition First processed position
	FirstPosition int `json:"first_position"`

	// GapsInWindow Gaps detected in the requested position window
	GapsInWindow *[]GapInfo `json:"gaps_in_window,omitempty"`

	// HasData Whether model has any processed data
	HasData bool `json:"has_data"`

	// LastEndPosition Last processed end position (max(position + interval))
	LastEndPosition int `json:"last_end_position"`

	// RangesInWindow Processed ranges overlapping the requested position window
	RangesInWindow *[]Range `json:"ranges_in_window,omitempty"`
}

// ModelSummary Lightweight model representation for listings
type ModelSummary struct {
	Database    string  `json:"database"`
	Description *string `json:"description,omitempty"`

	// Id Fully qualified ID (database.table)
	Id    string `json:"id"`
	Table string `json:"table"`

	// Type Model type
	Type ModelSummaryType `json:"type"`
}

// ModelSummaryType Model type
type ModelSummaryType string

// Range defines model for Range.
type Range struct {
	// Interval Size of processed range
	Interval int `json:"interval"`

	// Position Starting position of processed range
	Position int `json:"position"`
}

// ScheduledRun defines model for ScheduledRun.
type ScheduledRun struct {
	// Id Fully qualified model ID (database.table)
	Id string `json:"id"`

	// LastRun Timestamp of last execution
	LastRun *time.Time `json:"last_run,omitempty"`
}

// TransformationModel defines model for TransformationModel.
type TransformationModel struct {
	// Content SQL query or exec command defining the transformation
	Content string `json:"content"`

	// ContentType Execution method (SQL query or shell command)
	ContentType TransformationModelContentType `json:"content_type"`
	Database    string                         `json:"database"`

	// DependsOn Upstream model dependencies preserving AND/OR semantics.
	// - String elements represent required dependencies (AND logic)
	// - Array elements represent OR groups (at least one required)
	DependsOn   *[]TransformationModel_DependsOn_Item `json:"depends_on,omitempty"`
	Description *string                               `json:"description,omitempty"`

	// Id Fully qualified ID (database.table)
	Id string `json:"id"`

	// Interval Interval configuration (present when type=incremental)
	Interval *struct {
		// Max Maximum interval size
		Max *int `json:"max,omitempty"`

		// Min Minimum interval size
		Min *int `json:"min,omitempty"`

		// Type Type of interval (e.g., "second", "slot", "epoch", "block")
		Type *string `json:"type,omitempty"`
	} `json:"interval,omitempty"`

	// Limits Limits (present when type=incremental)
	Limits *struct {
		// Max Maximum position limit
		Max *int `json:"max,omitempty"`

		// Min Minimum position limit
		Min *int `json:"min,omitempty"`
	} `json:"limits,omitempty"`

	// Metadata System-managed metadata
	Metadata *struct {
		CreatedAt     *time.Time                                `json:"created_at,omitempty"`
		LastRunAt     *time.Time                                `json:"last_run_at,omitempty"`
		LastRunStatus *TransformationModelMetadataLastRunStatus `json:"last_run_status,omitempty"`
		RowCount      *int                                      `json:"row_count,omitempty"`
		SizeBytes     *int                                      `json:"size_bytes,omitempty"`
		UpdatedAt     *time.Time                                `json:"updated_at,omitempty"`
	} `json:"metadata,omitempty"`

	// Schedule Cron expression (present when type=scheduled)
	Schedule *string `json:"schedule,omitempty"`

	// Schedules Schedules (present when type=incremental)
	Schedules *struct {
		// Backfill Backfill schedule
		Backfill *string `json:"backfill,omitempty"`

		// Forwardfill Forward fill schedule
		Forwardfill *string `json:"forwardfill,omitempty"`
	} `json:"schedules,omitempty"`
	Table string `json:"table"`

	// Tags Tags for categorization
	Tags *[]string `json:"tags,omitempty"`

	// Type Transformation type (scheduled or incremental)
	Type TransformationModelType `json:"type"`
}

// TransformationModelContentType Execution method (SQL query or shell command)
type TransformationModelContentType string

// TransformationModelDependsOn0 Single required dependency (AND logic)
type TransformationModelDependsOn0 = string

// TransformationModelDependsOn1 OR group - at least one dependency required
type TransformationModelDependsOn1 = []string

// TransformationModel_DependsOn_Item defines model for TransformationModel.depends_on.Item.
type TransformationModel_DependsOn_Item struct {
	union json.RawMessage
}

// TransformationModelMetadataLastRunStatus defines model for TransformationModel.Metadata.LastRunStatus.
type TransformationModelMetadataLastRunStatus string

// TransformationModelType Transformation type (scheduled or incremental)
type TransformationModelType string

// TransformationModelBase defines model for TransformationModelBase.
type TransformationModelBase struct {
	// Content SQL query or exec command defining the transformation
	Content string `json:"content"`

	// ContentType Execution method (SQL query or shell command)
	ContentType TransformationModelBaseContentType `json:"content_type"`
	Database    string                             `json:"database"`

	// DependsOn Upstream model dependencies preserving AND/OR semantics.
	// - String elements represent required dependencies (AND logic)
	// - Array elements represent OR groups (at least one required)
	DependsOn   *[]TransformationModelBase_DependsOn_Item `json:"depends_on,omitempty"`
	Description *string                                   `json:"description,omitempty"`

	// Id Fully qualified ID (database.table)
	Id string `json:"id"`

	// Metadata System-managed metadata
	Metadata *struct {
		CreatedAt     *time.Time                                    `json:"created_at,omitempty"`
		LastRunAt     *time.Time                                    `json:"last_run_at,omitempty"`
		LastRunStatus *TransformationModelBaseMetadataLastRunStatus `json:"last_run_status,omitempty"`
		RowCount      *int                                          `json:"row_count,omitempty"`
		SizeBytes     *int                                          `json:"size_bytes,omitempty"`
		UpdatedAt     *time.Time                                    `json:"updated_at,omitempty"`
	} `json:"metadata,omitempty"`
	Table string `json:"table"`

	// Tags Tags for categorization
	Tags *[]string `json:"tags,omitempty"`

	// Type Transformation type (scheduled or incremental)
	Type TransformationModelBaseType `json:"type"`
}

// TransformationModelBaseContentType Execution method (SQL query or shell command)
type TransformationModelBaseContentType string

// TransformationModelBaseDependsOn0 Single required dependency (AND logic)
type TransformationModelBaseDependsOn0 = string

// TransformationModelBaseDependsOn1 OR group - at least one dependency required
type TransformationModelBaseDependsOn1 = []string

// TransformationModelBase_DependsOn_Item defines model for TransformationModelBase.depends_on.Item.
type TransformationModelBase_DependsOn_Item struct {
	union json.RawMessage
}

// TransformationModelBaseMetadataLastRunStatus defines model for TransformationModelBase.Metadata.LastRunStatus.
type TransformationModelBaseMetadataLastRunStatus string

// TransformationModelBaseType Transformation type (scheduled or incremental)
type TransformationModelBaseType string

// ValidationDebugInfo Validation results using the same logic as backfill/dependency checking
type ValidationDebugInfo struct {
	// BlockingGaps List of gaps blocking processing
	BlockingGaps *[]struct {
		DependencyId string `json:"dependency_id"`

		// Gap Information about a gap in coverage
		Gap GapInfo `json:"gap"`
	} `json:"blocking_gaps,omitempty"`

	// HasDependencyGaps Whether any dependencies have gaps in the requested range
	HasDependencyGaps bool `json:"has_dependency_gaps"`

	// InBounds Whether position is within valid bounds of all dependencies
	InBounds bool `json:"in_bounds"`

	// NextValidPosition Next position where dependencies are available (if blocked)
	NextValidPosition *int `json:"next_valid_position,omitempty"`

	// Reasons Human-readable reasons why position cannot be processed
	Reasons *[]string `json:"reasons,omitempty"`

	// ValidRange Valid position range calculated from dependencies
	ValidRange *struct {
		Max int `json:"max"`
		Min int `json:"min"`
	} `json:"valid_range,omitempty"`
}

// InternalError defines model for InternalError.
type InternalError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// ListAllModelsParams defines parameters for ListAllModels.
type ListAllModelsParams struct {
	// Type Filter by model type
	Type *ListAllModelsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Database Filter by database name
	Database *string `form:"database,omitempty" json:"database,omitempty"`

	// Search Search by model ID or description (case-insensitive)
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListAllModelsParamsType defines parameters for ListAllModels.
type ListAllModelsParamsType string

// ListExternalModelsParams defines parameters for ListExternalModels.
type ListExternalModelsParams struct {
	// Database Filter by database name
	Database *string `form:"database,omitempty" json:"database,omitempty"`
}

// ListTransformationsParams defines parameters for ListTransformations.
type ListTransformationsParams struct {
	// Database Filter by database name
	Database *string `form:"database,omitempty" json:"database,omitempty"`

	// Type Filter by transformation type
	Type *ListTransformationsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Status Filter by last run status
	Status *ListTransformationsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// ListTransformationsParamsType defines parameters for ListTransformations.
type ListTransformationsParamsType string

// ListTransformationsParamsStatus defines parameters for ListTransformations.
type ListTransformationsParamsStatus string

// ListTransformationCoverageParams defines parameters for ListTransformationCoverage.
type ListTransformationCoverageParams struct {
	// Database Filter by database name
	Database *string `form:"database,omitempty" json:"database,omitempty"`
}

// ListScheduledRunsParams defines parameters for ListScheduledRuns.
type ListScheduledRunsParams struct {
	// Database Filter by database name
	Database *string `form:"database,omitempty" json:"database,omitempty"`
}

// DebugCoverageAtPositionParams defines parameters for DebugCoverageAtPosition.
type DebugCoverageAtPositionParams struct {
	// Interval Interval size to check (defaults to model's max interval)
	Interval *int `form:"interval,omitempty" json:"interval,omitempty"`
}

// AsTransformationModelDependsOn0 returns the union data inside the TransformationModel_DependsOn_Item as a TransformationModelDependsOn0
func (t TransformationModel_DependsOn_Item) AsTransformationModelDependsOn0() (TransformationModelDependsOn0, error) {
	var body TransformationModelDependsOn0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransformationModelDependsOn0 overwrites any union data inside the TransformationModel_DependsOn_Item as the provided TransformationModelDependsOn0
func (t *TransformationModel_DependsOn_Item) FromTransformationModelDependsOn0(v TransformationModelDependsOn0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransformationModelDependsOn0 performs a merge with any union data inside the TransformationModel_DependsOn_Item, using the provided TransformationModelDependsOn0
func (t *TransformationModel_DependsOn_Item) MergeTransformationModelDependsOn0(v TransformationModelDependsOn0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransformationModelDependsOn1 returns the union data inside the TransformationModel_DependsOn_Item as a TransformationModelDependsOn1
func (t TransformationModel_DependsOn_Item) AsTransformationModelDependsOn1() (TransformationModelDependsOn1, error) {
	var body TransformationModelDependsOn1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransformationModelDependsOn1 overwrites any union data inside the TransformationModel_DependsOn_Item as the provided TransformationModelDependsOn1
func (t *TransformationModel_DependsOn_Item) FromTransformationModelDependsOn1(v TransformationModelDependsOn1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransformationModelDependsOn1 performs a merge with any union data inside the TransformationModel_DependsOn_Item, using the provided TransformationModelDependsOn1
func (t *TransformationModel_DependsOn_Item) MergeTransformationModelDependsOn1(v TransformationModelDependsOn1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransformationModel_DependsOn_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransformationModel_DependsOn_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTransformationModelBaseDependsOn0 returns the union data inside the TransformationModelBase_DependsOn_Item as a TransformationModelBaseDependsOn0
func (t TransformationModelBase_DependsOn_Item) AsTransformationModelBaseDependsOn0() (TransformationModelBaseDependsOn0, error) {
	var body TransformationModelBaseDependsOn0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransformationModelBaseDependsOn0 overwrites any union data inside the TransformationModelBase_DependsOn_Item as the provided TransformationModelBaseDependsOn0
func (t *TransformationModelBase_DependsOn_Item) FromTransformationModelBaseDependsOn0(v TransformationModelBaseDependsOn0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransformationModelBaseDependsOn0 performs a merge with any union data inside the TransformationModelBase_DependsOn_Item, using the provided TransformationModelBaseDependsOn0
func (t *TransformationModelBase_DependsOn_Item) MergeTransformationModelBaseDependsOn0(v TransformationModelBaseDependsOn0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTransformationModelBaseDependsOn1 returns the union data inside the TransformationModelBase_DependsOn_Item as a TransformationModelBaseDependsOn1
func (t TransformationModelBase_DependsOn_Item) AsTransformationModelBaseDependsOn1() (TransformationModelBaseDependsOn1, error) {
	var body TransformationModelBaseDependsOn1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTransformationModelBaseDependsOn1 overwrites any union data inside the TransformationModelBase_DependsOn_Item as the provided TransformationModelBaseDependsOn1
func (t *TransformationModelBase_DependsOn_Item) FromTransformationModelBaseDependsOn1(v TransformationModelBaseDependsOn1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTransformationModelBaseDependsOn1 performs a merge with any union data inside the TransformationModelBase_DependsOn_Item, using the provided TransformationModelBaseDependsOn1
func (t *TransformationModelBase_DependsOn_Item) MergeTransformationModelBaseDependsOn1(v TransformationModelBaseDependsOn1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TransformationModelBase_DependsOn_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TransformationModelBase_DependsOn_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get interval type transformations
	// (GET /interval/types)
	GetIntervalTypes(c fiber.Ctx) error
	// List all models (lightweight)
	// (GET /models)
	ListAllModels(c fiber.Ctx, params ListAllModelsParams) error
	// List external models
	// (GET /models/external)
	ListExternalModels(c fiber.Ctx, params ListExternalModelsParams) error
	// List external model bounds
	// (GET /models/external/bounds)
	ListExternalBounds(c fiber.Ctx) error
	// Get external model by ID
	// (GET /models/external/{id})
	GetExternalModel(c fiber.Ctx, id string) error
	// Get external model bounds by ID
	// (GET /models/external/{id}/bounds)
	GetExternalBounds(c fiber.Ctx, id string) error
	// List transformation models
	// (GET /models/transformations)
	ListTransformations(c fiber.Ctx, params ListTransformationsParams) error
	// List transformation coverage
	// (GET /models/transformations/coverage)
	ListTransformationCoverage(c fiber.Ctx, params ListTransformationCoverageParams) error
	// List scheduled transformation runs
	// (GET /models/transformations/runs)
	ListScheduledRuns(c fiber.Ctx, params ListScheduledRunsParams) error
	// Get transformation model by ID
	// (GET /models/transformations/{id})
	GetTransformation(c fiber.Ctx, id string) error
	// Get transformation coverage by ID
	// (GET /models/transformations/{id}/coverage)
	GetTransformationCoverage(c fiber.Ctx, id string) error
	// Debug coverage and dependency status for a specific position
	// (GET /models/transformations/{id}/coverage/{position})
	DebugCoverageAtPosition(c fiber.Ctx, id string, position int, params DebugCoverageAtPositionParams) error
	// Get scheduled transformation run by ID
	// (GET /models/transformations/{id}/runs)
	GetScheduledRun(c fiber.Ctx, id string) error
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

type MiddlewareFunc fiber.Handler

// GetIntervalTypes operation middleware
func (siw *ServerInterfaceWrapper) GetIntervalTypes(c fiber.Ctx) error {

	return siw.Handler.GetIntervalTypes(c)
}

// ListAllModels operation middleware
func (siw *ServerInterfaceWrapper) ListAllModels(c fiber.Ctx) error {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAllModelsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", query, &params.Type)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter type: %w", err).Error())
	}

	// ------------- Optional query parameter "database" -------------

	err = runtime.BindQueryParameter("form", true, false, "database", query, &params.Database)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter database: %w", err).Error())
	}

	// ------------- Optional query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, false, "search", query, &params.Search)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter search: %w", err).Error())
	}

	return siw.Handler.ListAllModels(c, params)
}

// ListExternalModels operation middleware
func (siw *ServerInterfaceWrapper) ListExternalModels(c fiber.Ctx) error {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListExternalModelsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "database" -------------

	err = runtime.BindQueryParameter("form", true, false, "database", query, &params.Database)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter database: %w", err).Error())
	}

	return siw.Handler.ListExternalModels(c, params)
}

// ListExternalBounds operation middleware
func (siw *ServerInterfaceWrapper) ListExternalBounds(c fiber.Ctx) error {

	return siw.Handler.ListExternalBounds(c)
}

// GetExternalModel operation middleware
func (siw *ServerInterfaceWrapper) GetExternalModel(c fiber.Ctx) error {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Params("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter id: %w", err).Error())
	}

	return siw.Handler.GetExternalModel(c, id)
}

// GetExternalBounds operation middleware
func (siw *ServerInterfaceWrapper) GetExternalBounds(c fiber.Ctx) error {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Params("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter id: %w", err).Error())
	}

	return siw.Handler.GetExternalBounds(c, id)
}

// ListTransformations operation middleware
func (siw *ServerInterfaceWrapper) ListTransformations(c fiber.Ctx) error {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTransformationsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "database" -------------

	err = runtime.BindQueryParameter("form", true, false, "database", query, &params.Database)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter database: %w", err).Error())
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", query, &params.Type)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter type: %w", err).Error())
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", query, &params.Status)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter status: %w", err).Error())
	}

	return siw.Handler.ListTransformations(c, params)
}

// ListTransformationCoverage operation middleware
func (siw *ServerInterfaceWrapper) ListTransformationCoverage(c fiber.Ctx) error {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTransformationCoverageParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "database" -------------

	err = runtime.BindQueryParameter("form", true, false, "database", query, &params.Database)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter database: %w", err).Error())
	}

	return siw.Handler.ListTransformationCoverage(c, params)
}

// ListScheduledRuns operation middleware
func (siw *ServerInterfaceWrapper) ListScheduledRuns(c fiber.Ctx) error {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListScheduledRunsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "database" -------------

	err = runtime.BindQueryParameter("form", true, false, "database", query, &params.Database)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter database: %w", err).Error())
	}

	return siw.Handler.ListScheduledRuns(c, params)
}

// GetTransformation operation middleware
func (siw *ServerInterfaceWrapper) GetTransformation(c fiber.Ctx) error {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Params("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter id: %w", err).Error())
	}

	return siw.Handler.GetTransformation(c, id)
}

// GetTransformationCoverage operation middleware
func (siw *ServerInterfaceWrapper) GetTransformationCoverage(c fiber.Ctx) error {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Params("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter id: %w", err).Error())
	}

	return siw.Handler.GetTransformationCoverage(c, id)
}

// DebugCoverageAtPosition operation middleware
func (siw *ServerInterfaceWrapper) DebugCoverageAtPosition(c fiber.Ctx) error {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Params("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter id: %w", err).Error())
	}

	// ------------- Path parameter "position" -------------
	var position int

	err = runtime.BindStyledParameterWithOptions("simple", "position", c.Params("position"), &position, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter position: %w", err).Error())
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DebugCoverageAtPositionParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, false, "interval", query, &params.Interval)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter interval: %w", err).Error())
	}

	return siw.Handler.DebugCoverageAtPosition(c, id, position, params)
}

// GetScheduledRun operation middleware
func (siw *ServerInterfaceWrapper) GetScheduledRun(c fiber.Ctx) error {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Params("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter id: %w", err).Error())
	}

	return siw.Handler.GetScheduledRun(c, id)
}

// FiberServerOptions provides options for the Fiber server.
type FiberServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router fiber.Router, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, FiberServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router fiber.Router, si ServerInterface, options FiberServerOptions) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	for _, m := range options.Middlewares {
		router.Use(fiber.Handler(m))
	}

	router.Get(options.BaseURL+"/interval/types", wrapper.GetIntervalTypes)

	router.Get(options.BaseURL+"/models", wrapper.ListAllModels)

	router.Get(options.BaseURL+"/models/external", wrapper.ListExternalModels)

	router.Get(options.BaseURL+"/models/external/bounds", wrapper.ListExternalBounds)

	router.Get(options.BaseURL+"/models/external/:id", wrapper.GetExternalModel)

	router.Get(options.BaseURL+"/models/external/:id/bounds", wrapper.GetExternalBounds)

	router.Get(options.BaseURL+"/models/transformations", wrapper.ListTransformations)

	router.Get(options.BaseURL+"/models/transformations/coverage", wrapper.ListTransformationCoverage)

	router.Get(options.BaseURL+"/models/transformations/runs", wrapper.ListScheduledRuns)

	router.Get(options.BaseURL+"/models/transformations/:id", wrapper.GetTransformation)

	router.Get(options.BaseURL+"/models/transformations/:id/coverage", wrapper.GetTransformationCoverage)

	router.Get(options.BaseURL+"/models/transformations/:id/coverage/:position", wrapper.DebugCoverageAtPosition)

	router.Get(options.BaseURL+"/models/transformations/:id/runs", wrapper.GetScheduledRun)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
